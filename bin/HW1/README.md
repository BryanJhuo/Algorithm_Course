# Homework1
HackMD版：[HackMD](https://hackmd.io/@4COkbbBoTXCZqkARAfT_sg/By1QxfCcye)
## The Battle Game
戰爭（War）是一款兩名玩家之間的紙牌遊戲。在每場遊戲開始時，52 張牌會被隨機分成兩副等量的牌組，分別分配給兩位對手。遊戲的結果完全取決於卡牌的初始分配。本次作業的目標是編寫一個程式來洗牌、模擬遊戲進行過程，並指示最終的勝者（也有可能出現「平局」）。
## 1 Card decks
在接下來的內容中，nbVals 代表牌組中不同數值的數量，理論上應為 13，但我們允許在測試中使用更多或更少的數值。另一方面，我們始終使用 4 種花色。因此，牌組中每個數值都會有 4 張牌，總共包含 4 * nbVals 張牌。根據約定，我們將數值編號從 1 到 nbVals。  
在戰爭（Battle）遊戲中，卡牌的花色不會被考慮。因此，一副牌可以被視為一列整數（我們從上方取牌，並從下方加入新牌），這些整數的範圍介於 1 到 nbVals 之間，且相同的整數最多出現 4 次。因此，一副牌最多包含 4 * nbVals 張牌。  

牌組使用 鏈結串列（Linked List） 來表示，即 LinkedList<Integer>，並封裝在 Deck 類別中，該類別已經包含以下內容：  
- 一個欄位 LinkedList<Integer> cards，用來儲存牌組。
- 以下構造函式：
    - Deck()：建立一副空牌組。
    - Deck(LinkedList<Integer> cards)：建立一副已指定 cards 欄位的牌組。
    - Deck(int nbVals)：建立一副數值按遞增順序排列的完整牌組。
- 方法：
    - Deck copy()：返回當前牌組的複本 returns a copy of the deck。
    - String toString()：返回表示此牌組的字串 returns a string representing the deck。  
    
在 Deck 類別中，請完成以下方法：
- int pick(Deck d)：
    - 如果牌組 d 不為空，則移除其 第一張 牌，並將該牌加入當前牌組（this）的末尾，最後返回該牌的數值。
    - 如果 d 為空，則返回 -1，且兩副牌組均保持不變。
- void pickAll(Deck d)：
    - 逐一從 d 中移除所有牌，並將其添加到當前牌組的末尾。
- boolean isValid(int nbVals)：
    - 若當前牌組為有效牌組，則返回 true。即：
            § 所有數值皆在 {1, ..., nbVals} 範圍內。
            § 相同數值的卡片數量不超過 4 張。

## 2 The American mix
**美式洗牌（American shuffle）**，或英文稱為 riffle shuffle，是一種常見的紙牌洗牌技術（即對牌組的元素進行隨機排列），其步驟如下：
1. 將牌組隨機分成兩疊（通常夾在雙手的拇指和食指之間）。  
2. 然後依序將牌張逐張落下，使兩疊牌交錯混合（這個過程稱為 riffle）。  

此操作可透過教學影片來示範，並且在 維基百科 頁面中有詳細解釋。  

我們將在`Deck`類別中實作一個方法來執行這種洗牌方式。  

### 2.1 The cut

將牌組切割成兩個子牌組的過程是隨機進行的，並且大約在牌堆的中間進行。我們會選擇**遵循二項分佈**（binomial distribution）來進行隨機抽取，而非均勻分佈（uniform distribution）。  

二項分佈的參數`n`（在此練習中，`n`是牌組的大小）是透過對公平硬幣進行 `n`次拋擲，並計算獲得「正面（heads）」的次數來獲得的（每次拋擲結果為「正面」或「反面（tails）」）。  

我們可以使用`double Math.random()`方法（該方法返回`[0, 1]`區間內的隨機值）來模擬這種拋擲過程。  

#### 在`Deck`類別中，請完成以下方法：
1.`int cut()` 方法

該方法應該返回「第一副牌組」的牌數`c`，其值應 依照二項分佈隨機選擇。

測試方法：
執行`Test21a.java`來測試你的程式碼。
該程式碼會計算**sup norm**（最大偏差）來比較理論上的 二項分佈（參數 `n`）與透過`cut()`方法進行`m`次呼叫後得到的**實驗數據**。

當`n = 52`（一副標準撲克牌）且`m = 100000`（執行 10 萬次 `cut()`），偏差通常不超過`0.0025`。

2.`Deck split()` 方法
該方法應該執行以下操作：
- 呼叫`cut()`方法獲取 `c`（第一副牌組的牌數）。
- 從當前牌組中移除前`c`張牌，並返回這些牌作為新的`Deck`。

測試方法：
執行`Test21b.java`來測試你的程式碼。
該程式碼會對一副 52 張牌的牌組 進行約 100 次切割，並檢查兩個切分後的牌組是否能合併回完整的 52 張牌。

### 2.2 The Riffle

在 riffle 洗牌 中，下一張落下的牌來自切割後的兩個牌堆之一。  
這張牌來自第一個牌堆的機率為`a / (a + b)`，其中`a`和`b`分別代表兩個牌堆中的剩餘牌數。這種機率設計能夠相當真實地模擬實際的洗牌過程。  
需要注意的是，每當一張牌落下時，`a`和`b`這兩個參數都必須即時更新。  

#### 在`Deck`類別中，請完成以下方法：
`void riffleWith(Deck d)` 方法  
該方法應該將 當前牌組 與 牌組`d`進行交錯混合。執行完畢後：  
- 牌組`d`變為空。 
- 洗牌結果儲存在當前牌組。  
  
提示：
- 建立一個 空的第三副牌組`f`。  
- 持續呼叫`pick()`方法，從當前牌組 (`this`) 和`d`交錯取牌，直到兩副牌都被取完。  
- 最後，將`f.cards`內的結果 更新至當前牌組 (`this.cards`)。  

#### 測試方法：
執行`Test22.java`來測試你的程式碼。該程式會進行以下驗證：

1. 測試 1（10000 次洗牌測試）
   - 交錯洗牌兩副牌組：
      - 第一副：`1, 2, ..., 26`
      - 第二副：`27, 28, ..., 52`
   - 檢查洗牌後的結果是否完整包含這兩副牌組，且牌的相對順序不變。

2. 測試 2（10000 次組合測試）
   - 交錯洗牌兩副牌組：  
     - 第一副：`1, 2, 3, 4, 5`
     - 第二副：`6, 7, 8, 9, 10`
   - 確保 所有 252 種可能的洗牌結果（`252` 是二項係數 `C(5,10)`）都至少出現一次。

### 2.3 整合所有步驟
美式洗牌（American shuffle）後，卡牌的分布 並非完全均勻，因為在 切牌（cut） 完成後，每個子牌堆的 順序會在洗牌（riffle）過程中保持不變。
然而，根據 D. Bayer 和 P. Diaconis 在一篇著名的論文中所證明的結果：
- **當洗牌過程重複足夠次數（約 log n 次，對 n 張牌而言）時，最終的分布會趨近於（幾乎）完全隨機。**
- **對一副 52 張的牌組來說，進行 7 次美式洗牌已經足夠讓其達到良好的隨機分布。**
    
#### 在 Deck 類別中，請完成以下方法：
`void riffleShuffle(int m)`
該方法應該執行 `m` 次美式洗牌（即 切牌 `split()` 然後洗牌 `riffleWith()`），以隨機排列當前牌組。

#### 測試方法：
執行 Test23.java 來測試你的程式碼。該程式將執行 一百萬次（1,000,000 次）洗牌實驗，步驟如下：
1. 建立一副新的 52 張牌組。
2. 透過 riffleShuffle(7) 方法來洗牌。
3. 檢查 結果是否可疑。
    
#### 洗牌結果的判斷標準（可疑牌組）
若 一副牌組 同時符合以下 任一條件，則視為 可疑：   
- 14 對相鄰的相同卡牌（twins），即出現 14 次「連續兩張相同的數字」。
- 3 組 4 張連續相同的卡牌（quadruplets），即出現 3 次「四張連續相同數字的卡牌」。
- 2 組 8 張卡牌中只包含 2 種不同數值（octuplets），即有 2 次「8 張連續卡牌的數值只出現 2 種」。
    
#### 根據實驗結果：
- 在 100 萬次洗牌測試中，通常不會出現超過 5 組「可疑牌組」。
- 如果出現過多可疑牌組，請重新執行測試。
- 如果異常情況持續發生，請檢查你的程式碼 😆。
    
#### 文化補充
然而，卡牌分布的「收斂速度」並非線性增加，其中有一個關鍵的 臨界點（threshold）：
- 當洗牌次數超過這個門檻，牌組會趨近於均勻隨機分布。
- 但若低於這個門檻，則牌組仍然會保留較明顯的結構。
    
這個特性是許多**魔術技巧的基礎**，例如操控洗牌後的卡牌順序，使其看似隨機但實際上可預測。
有興趣的話，可以參考**Diaconis、Graham**和**Kantor**的論文第三部分，該部分提供了更多關於這個現象的數學細節。
**小趣聞**：Diaconis 在成為一位著名的機率學家（probabilist）之前，其實是一位知名魔術師！🎩✨
    
    
## 3 Simulation of a battle game
戰爭（Battle）遊戲的規則很簡單：
- 遊戲開始時，所有卡牌會平均分配給兩位玩家，並且玩家將卡牌放在自己面前的牌堆中（不能查看牌面）。
- 每回合，每位玩家從自己的牌堆頂部抽出一張牌。
    - **數值較高的玩家獲勝**，並將兩張牌都放到自己的牌堆底部。
    - 如果兩張牌的數值相同，則進入**戰爭（Battle）**：
        - 每位玩家再從自己的牌堆頂部抽 兩張牌：
        - 第一張牌放到場上（不查看牌面）。
        - 第二張牌用來比對 對手的牌。
    - 如果再次發生平手，則重複這個過程，直到分出勝負。
    - 一旦有玩家的牌較大，則該玩家獲得這輪的所有牌。
- 遊戲結束條件：
    - 進行 n 輪後（n 事先設定）遊戲結束，或
    - 任意一位玩家的牌全部用完。
- 遊戲結束時：
    - 擁有較多牌的玩家獲勝。
    - 如果雙方牌數相同，則平手。
    
### 3.1 Start of the game
`Battle`類別用來模擬戰爭（Battle）遊戲的進行，其中包含以下內容：

#### 屬性（Fields）
- `player1`、`player2` 和 `trick`（類型皆為`Deck`），代表遊戲當前的狀態：
    - `player1`：第一位玩家的牌組。
    - `player2`：第二位玩家的牌組。
    - `trick`：場上正在進行的比賽區（棄牌區）。
#### 建構函式（Constructors）
- `Battle()`：建立一個空的戰爭遊戲。
- `Battle(Deck player1, Deck player2, Deck trick)`：
    - 透過給定的`player1`、`player2`和`trick`來建立一場戰爭遊戲。
#### 方法（Methods）
- `Battle copy()`： 返回當前戰爭遊戲的複本。
- `String toString()`：返回代表當前戰爭遊戲的字串。
    
#### 需要完成的方法
`Battle(int nbVals)` 建構函式
此建構函式的目標是初始化一場戰爭遊戲，也就是說，它需要執行以下步驟：
1. 建立一副新的 Deck（共 4 * nbVals 張牌）
    - 使用 Deck(int nbVals) 來建立完整的牌組。
2. 洗牌
    - 使用 riffleShuffle(7) 方法執行 7 次美式洗牌，確保牌組充分隨機化。
3. 將牌分發給兩位玩家
    - 交替發牌：第一張給 player1，第二張給 player2，如此反覆進行，直到牌發完。
    
#### 測試方式
執行`Test31.java`來測試你的程式碼。
這個測試會檢查：
- 遊戲是否正確初始化（牌組數量是否正確）。
- 牌是否交替發放給玩家。
- 牌是否經過充分洗牌。
    
### 3.2 Progress of a fold
在`Battle`類別中，請完成以下方法：
#### 1.`boolean isOver()` 方法
**目標**：判斷遊戲是否結束。

**實作邏輯**：
- 如果任一玩家的牌組為空，則遊戲結束，返回`true`。
- 否則遊戲仍在進行，返回`false`。
#### 2.`boolean oneRound()`方法
**目標**：模擬 一回合的對戰（trick），包括可能發生的 戰爭（battle）。
**回合流程**
1. 兩位玩家各抽一張牌放入`trick`
    - 先由`player1`抽牌，然後`player2`抽牌。
2. 比較兩張牌的數值，決定勝負
    - 較大數值的玩家獲勝：該玩家獲得`trick`內的所有牌（順序不變）。
    - 若兩張牌相同，則進入「**戰爭（battle）**」：
        - 每位玩家再抽一張牌放入`trick`（這些牌不進行比較）。
        - 重新回到`step 1`繼續對戰，直到有玩家獲勝。
3. 方法返回值
- 如果某位玩家在戰爭過程中無牌可抽：方法立即返回`false`（遊戲結束）。
- 若雙方皆有足夠的牌完成對戰：方法返回`true`（遊戲繼續）。

#### 特殊情況處理
- 若某位玩家在翻牌時已無牌可抽：方法直接返回`false`（遊戲結束）。
- 如果某位玩家在翻開最後一張牌後輸掉回合：方法仍然可以返回`true`，因為這表示遊戲仍可繼續進行。
- 如果雙方在戰爭時同時沒牌可抽：方法返回`false`（遊戲結束）。
    
#### 測試方式
執行`Test32.java`來測試：

`isOver()`是否能正確檢查遊戲結束條件。
`oneRound()`是否能正確模擬每一回合的對戰，包含一般比賽和戰爭情況。

### 3.3 Game progress
在`Battle`類別中，請完成以下方法：

#### 1.`int winner()` 方法
- 目標：確定目前遊戲的勝利者。
    - 若`player1`的牌數多於`player2`，返回`1`。
    - 若`player2`的牌數多於`player`1，返回`2`。
    - 若雙方牌數相同，返回`0`（平手）。
#### 2.`int game(int turns)` 方法
- 目標：模擬一場遊戲，並確保遊戲最多進行 turns 回合（turns 為最多可執行的對戰數）。
- 每回合執行 oneRound()，直到：
    1. 遊戲結束條件觸發（某位玩家沒有牌）。
    2. 已執行 turns 次對戰。
- 回傳值：
    - 若遊戲結束時 player1 牌數較多，則返回 1。
    - 若 player2 牌數較多，則返回 2。
    - 若雙方牌數相同，則返回 0（平手）。

#### 測試方式
執行`Test33.java`來檢查：
- `winner()`是否能正確判斷遊戲勝者。
- `game(int turns)`是否能正確模擬遊戲，並在達到最大回合數或遊戲結束時返回正確結果。
    
## 4 Infinite games (optional but exciting)
到目前為止，我們只考慮了預先設定有限步數的戰爭遊戲。我們將解除這一限制。
為了實現這一點，我們需要在模擬器中添加一個機制來檢測無限遊戲。我們用`S_k`來表示遊戲在第`k`回合的狀態，也就是在第`k`回合時兩位玩家所持有的牌組。
當狀態序列`S0, S1, ... , Sk, ...`是無限的時，遊戲即為無限遊戲。由於可能的不同狀態數量是有限的，且狀態`S_k+1`完全由`S_k`決定，因此這樣的序列必定會從某個回合開始週期性重複。
我們將同時進行兩場遊戲`b1`和`b2`。在兩場遊戲開始時，玩家擁有相同的手牌，但第二場遊戲（即`b2`）每當第一場遊戲（即`b1`）執行一次對戰時，執行兩次對戰。換句話說，我們計算：
- `S0, S1, ... , S_i, ...`（原始遊戲）
- `S0, S2, ... , S_2i, ...`（加速遊戲）

當且僅當存在某個整數`i`使得`S_i = S_2i`時，遊戲為無限遊戲。這正是 Floyd 提出的**龜兔算法（Hare and Tortoise Algorithm）**。

### 4.1 Implementation
我們已提供`Battle copy()`方法，它會返回`Battle`類別的一個克隆（clone）。
克隆後的物件與原始物件佔據不同的記憶體位置，因此修改其中一個不會影響另一個。
#### 如何比較兩場 Battle 是否相同？
-    可以使用 toString() 方法將 Battle 物件轉為字串，然後進行比較：`b1.toString().equals(b2.toString())`
若`b1`和`b2`的字串表示相同，則它們代表相同的遊戲狀態。

#### `game()` 方法的目標
在`Battle`類別中，請完成`int game()`方法，使其同時執行：
1.**「龜速遊戲」（Turtle Game）**
- 由 Battle copy() 方法建立的克隆 b1_copy 來執行。
- 每回合執行 一次 oneRound()。

2.**「兔速遊戲」（Hare Game）**
- 由 this（原始 Battle 物件）執行。
- 每回合執行 兩次 oneRound()（加快速度）。

這兩場遊戲擁有相同的初始狀態，並且同時進行。

#### 回傳值
- 若遊戲結束（winner() 方法決定勝負）
    - 若雙方皆無牌可抽 → 返回 0（平手）。
    - 若 player1 牌數較多 → 返回 1（player1 獲勝）。
    - 若 player2 牌數較多 → 返回 2（player2 獲勝）。
- 若遊戲進入無限循環（Hare and Tortoise Algorithm）
    - 若某回合發現 b1_copy.toString().equals(this.toString())，則表示遊戲進入循環，返回 3（無限遊戲）。

#### 實作步驟
1. 建立`Battle`的克隆（`b1_copy`），它負責執行「龜速遊戲」。
2. 進入回合循環，每回合：
    - `b1_copy` 執行 1 次 `oneRound()`（龜速）。
    - `this` 執行 2 次 `oneRound()`（兔速）。
3. 檢查遊戲是否結束：若 `winner()` 確定勝負，則返回 1、2 或 0。
4. 檢測是否進入無限循環：若 `b1_copy.toString().equals(this.toString())`，則返回 3（遊戲進入循環）。
5. 若遊戲結束，`this`應包含最終狀態。

#### 測試方式
執行`Test41.java`來測試：
- 遊戲能否正常進行，並根據結果返回正確值（0、1、2 或 3）。
- 遊戲能否偵測無限循環，並及時結束。

    
### 4.2 Statistics
在`Battle`類別中，請完成以下方法：
1.`static void stats(int nbVals, int nbGames)`方法
**目標：**
- 模擬`nbGames`場戰爭遊戲，每場遊戲使用`nbVals`個不同數值的牌組。
- 統計遊戲結果：
    - `player1`獲勝的次數。
    - `player2`獲勝的次數。
    - 無限遊戲（偵測是否發生循環）。
    - 平手的場數（雙方都沒牌可抽）。
**方法邏輯：**
1. 透過`for`迴圈執行`nbGames`場遊戲：
    - 建立`Battle`物件並開始遊戲。
    - 根據`game()`方法的返回值更新統計數據：
        - 若`game()`返回`1`，則`player1`勝場數 +1。
        - 若`game()`返回`2`，則`player2`勝場數 +1。
        - 若`game()`返回`0`，則記錄為平手。
        - 若`game()`返回`3`，則記錄為無限遊戲。
2. 顯示統計結果：列印`player1`和`player2`的勝場數、無限遊戲數和平手數。

#### 2. 測試方法
執行`Test42.java`多次，分別測試：
- 44 張牌（11 個數值）
- 48 張牌（12 個數值）
- 52 張牌（13 個數值）
**觀察結果：**
- 是否`player1`或`player2`有明顯的勝率偏差？
- 無限遊戲的發生率是多少？

#### 3. 修正`Battle`類別，使`player1`和`player2`輪流先出牌
目前`player1`總是先出牌，這可能影響遊戲結果。因此我們要修改`Battle` 類別，讓兩位玩家輪流先出牌。
**修改方式**
1. 新增`boolean turn`欄位：
- 在`Battle`類別中新增`boolean turn`，並在建構函式中初始化為 `true`。
- `true`表示`player1`先出牌，`false`表示`player2`先出牌。
2. 修改`oneRound()`方法：
- 每回合開始時：
    - 若`turn == true`，則`player1`先出牌，接著`player2`。
    - 若`turn == false`，則`player2`先出牌，接著`player1`。
- 回合結束後，翻轉`turn`的值（`turn = !turn;`）。

#### 4.重新執行`Test42.java`
這次`player1`和`player2`應該會公平地輪流先出牌，觀察遊戲結果是否變得更均衡。